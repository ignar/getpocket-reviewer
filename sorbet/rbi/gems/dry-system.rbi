# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/dry-system/all/dry-system.rbi
#
# dry-system-0.18.1

module Dry
end
module Dry::System
  def self.providers; end
  def self.register_component(identifier, provider:, &block); end
  def self.register_provider(identifier, options); end
  include Dry::Core::Constants
end
module Dry::System::Settings
end
class Dry::System::Settings::FileParser
  def call(file); end
  def parse_line(line, hash); end
  def parse_value(value); end
end
class Dry::System::Settings::FileLoader
  def call(root, env); end
  def files(root, env); end
  def parser; end
end
class Dry::System::Settings::DSL < BasicObject
  def call; end
  def identifier; end
  def initialize(identifier, &block); end
  def key(name, type); end
  def schema; end
end
class Dry::System::Settings::Configuration < Dry::Struct
  def self.init(root, env); end
  def self.load_files(root, env); end
  def self.setting(*args); end
  extend Dry::Core::DescendantsTracker
end
class Dry::System::Lifecycle < BasicObject
  def call(*triggers); end
  def component; end
  def config; end
  def configure(&block); end
  def container; end
  def init(&block); end
  def initialize(container, opts, &block); end
  def method_missing(meth, *args, &block); end
  def opts; end
  def register(*args, &block); end
  def self.cache; end
  def self.new(container, opts = nil, &block); end
  def settings(&block); end
  def start(&block); end
  def statuses; end
  def stop(&block); end
  def target; end
  def trigger!(name, &block); end
  def triggers; end
  def use(*names); end
end
module Dry::System::Components
end
class Dry::System::Components::Config
  def initialize; end
  def method_missing(meth, value = nil); end
  def self.new(&block); end
  def to_hash; end
end
class Dry::System::Components::Bootable
  def after(event, &block); end
  def before(event, &block); end
  def block; end
  def bootable?; end
  def config; end
  def configure!; end
  def configure(&block); end
  def container; end
  def finalize; end
  def identifier; end
  def init; end
  def initialize(identifier, options = nil, &block); end
  def lf_container; end
  def lifecycle; end
  def namespace; end
  def new(identifier, new_options = nil); end
  def options; end
  def settings(&block); end
  def start; end
  def statuses; end
  def stop; end
  def trigger(key, event); end
  def triggers; end
  def with(new_options); end
end
class Dry::System::Provider
  def boot_file(name); end
  def boot_files; end
  def boot_path; end
  def component(name, options = nil); end
  def components; end
  def identifier; end
  def initialize(identifier, options); end
  def load_components; end
  def options; end
  def register_component(name, fn); end
end
class Dry::System::ProviderRegistry
  def [](identifier); end
  def each(&block); end
  def initialize; end
  def items; end
  def register(identifier, options); end
  include Enumerable
end
class Dry::System::FileNotFoundError < StandardError
  def initialize(component); end
end
class Dry::System::ComponentFileMismatchError < StandardError
  def initialize(component); end
end
class Dry::System::ComponentLoadError < StandardError
  def initialize(component); end
end
class Dry::System::InvalidComponentError < ArgumentError
  def initialize(name, reason = nil); end
end
class Dry::System::InvalidComponentIdentifierError < ArgumentError
  def initialize(name); end
end
class Dry::System::InvalidComponentIdentifierTypeError < ArgumentError
  def initialize(name); end
end
class Dry::System::ComponentNotStartedError < StandardError
  def initialize(component_name); end
end
class Dry::System::PluginNotFoundError < StandardError
  def initialize(plugin_name); end
end
class Dry::System::ComponentsDirMissing < StandardError
end
class Dry::System::DuplicatedComponentKeyError < ArgumentError
end
class Dry::System::InvalidSettingsError < ArgumentError
  def attributes_errors(attributes); end
  def initialize(attributes); end
end
class Dry::System::PluginDependencyMissing < StandardError
  def initialize(plugin, message, gem = nil); end
end
class Dry::System::Loader
  def call(*args); end
  def constant; end
  def inflector; end
  def initialize(path, inflector = nil); end
  def path; end
  def singleton?(constant); end
end
class Dry::System::Booter
  def boot_dependency(component); end
  def boot_file(name); end
  def boot_files; end
  def bootable?(component); end
  def booted; end
  def call(name_or_component); end
  def components; end
  def finalize!; end
  def find_boot_file(name); end
  def init(name_or_component); end
  def initialize(paths); end
  def load_component(path); end
  def paths; end
  def register_component(component); end
  def require_boot_file(identifier); end
  def shutdown; end
  def start(name_or_component); end
  def stop(name_or_component); end
  def with_component(id_or_component); end
end
class Dry::System::Booter::ComponentRegistry
  def [](name); end
  def components; end
  def each(&block); end
  def exists?(name); end
  def initialize; end
  def register(component); end
  include Enumerable
end
class Dry::System::MagicCommentsParser
  def self.call(file_name); end
  def self.coerce(value); end
end
class Dry::System::AutoRegistrar
  def call(dir); end
  def component(path, **options); end
  def components(dir); end
  def config; end
  def container; end
  def file_options(file_name); end
  def files(dir); end
  def finalize!; end
  def initialize(container); end
  def register(*args, &block); end
  def registered?(name); end
  def relative_path(dir, file_path); end
  def root; end
end
class Dry::System::AutoRegistrar::Configuration
  def exclude(&block); end
  def initialize; end
  def instance(&block); end
  def memoize; end
  def memoize=(arg0); end
  def self.setting(name); end
end
class Dry::System::ManualRegistrar
  def call(name); end
  def config; end
  def container; end
  def file_exists?(name); end
  def finalize!; end
  def initialize(container); end
  def registrations_dir; end
  def root; end
end
class Dry::System::Importer
  def [](name); end
  def call(ns, other); end
  def container; end
  def finalize!; end
  def initialize(container); end
  def key?(name); end
  def register(other); end
  def registry; end
  def separator; end
end
class Dry::System::Component
  def auto_register?; end
  def bootable?; end
  def file; end
  def file_exists?(paths); end
  def identifier; end
  def initialize(identifier, path, options); end
  def instance(*args); end
  def loader; end
  def namespace; end
  def namespaced(namespace); end
  def namespaces; end
  def options; end
  def path; end
  def prepend(name); end
  def root_key; end
  def self.cache; end
  def self.extract_identifier(name, ns, sep); end
  def self.new(*args, &block); end
  def self.remove_namespace_from_name(name, ns); end
  def separator; end
  include Anonymous_Dry_Equalizer_35
  include Dry::Equalizer::Methods
end
module Anonymous_Dry_Equalizer_35
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Dry::System::Plugins
  def enabled_plugins; end
  def inherited(klass); end
  def self.loaded_dependencies; end
  def self.register(name, plugin, &block); end
  def self.registry; end
  def use(name, options = nil); end
end
module Dry::System::Plugins::Bootsnap
  def bootsnap_available?; end
  def self.dependencies; end
  def self.extended(system); end
  def setup_bootsnap; end
end
module Dry::System::Plugins::Logging
  def log_dir_path; end
  def log_file_name; end
  def log_file_path; end
  def log_level; end
  def register_logger; end
  def self.extended(system); end
end
class Dry::System::Plugins::Env < Module
  def extended(system); end
  def inferrer; end
  def initialize(options); end
  def options; end
end
module Dry::System::Plugins::Notifications
  def register_notifications; end
  def self.dependencies; end
  def self.extended(system); end
end
module Dry::System::Plugins::Monitoring
  def monitor(key, **options, &block); end
  def self.dependencies; end
  def self.extended(system); end
end
class Dry::System::Plugins::Monitoring::Proxy < SimpleDelegator
  def initialize(target, notifications); end
  def self.for(target, key:, methods: nil); end
end
module Dry::System::Plugins::DependencyGraph
  def register(key, contents = nil, options = nil, &block); end
  def self.dependencies; end
  def self.extended(system); end
end
class Dry::System::Plugins::DependencyGraph::Strategies
  extend Anonymous_Module_36
  extend Dry::Configurable
  extend Dry::Configurable::ClassMethods
  extend Dry::Container::Mixin
end
module Anonymous_Module_36
  def inherited(subclass); end
end
class Dry::System::Plugins::DependencyGraph::Strategies::Kwargs < Dry::AutoInject::Strategies::Kwargs
  def define_initialize(klass); end
end
class Dry::System::Plugins::Plugin
  def apply_to(system, options); end
  def block; end
  def initialize(name, mod, &block); end
  def load_dependencies(dependencies = nil, gem = nil); end
  def load_dependency(dependency, gem); end
  def mod; end
  def mod_dependencies; end
  def name; end
  def stateful?; end
end
class Dry::System::Container
  def self.after(event, &block); end
  def self.auto_register!(dir, &block); end
  def self.auto_registrar; end
  def self.before(event, &block); end
  def self.boot(name, **opts, &block); end
  def self.boot_external(identifier, from:, key: nil, namespace: nil, &block); end
  def self.boot_local(identifier, namespace: nil, &block); end
  def self.boot_paths; end
  def self.booter; end
  def self.component(identifier, **options); end
  def self.configure(&block); end
  def self.finalize!(freeze: nil, &block); end
  def self.finalize(*args, &block); end
  def self.finalized?; end
  def self.hooks; end
  def self.import(other); end
  def self.importer; end
  def self.inherited(klass); end
  def self.init(name); end
  def self.injector(options = nil); end
  def self.key?(key); end
  def self.load_component(key, &block); end
  def self.load_imported_component(component); end
  def self.load_local_component(component, default_namespace_fallback = nil, &block); end
  def self.load_paths!(*dirs); end
  def self.load_paths; end
  def self.load_registrations!(name); end
  def self.manual_registrar; end
  def self.registered?(key); end
  def self.require_component(component); end
  def self.require_from_root(*paths); end
  def self.require_path(path); end
  def self.resolve(key, &block); end
  def self.root; end
  def self.setting(name, *args, &block); end
  def self.shutdown!; end
  def self.start(name); end
  def self.stop(name); end
  def self.strategies(value = nil); end
  extend Anonymous_Module_37
  extend Anonymous_Module_38
  extend Dry::Configurable
  extend Dry::Configurable
  extend Dry::Configurable::ClassMethods
  extend Dry::Configurable::ClassMethods
  extend Dry::Container::Mixin
  extend Dry::System::Plugins
end
module Anonymous_Module_37
  def inherited(subclass); end
end
module Anonymous_Module_38
  def components; end
  def self.define(name); end
end
