# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/dry-transaction/all/dry-transaction.rbi
#
# dry-transaction-0.13.0

module Dry
  def self.Transaction(container: nil, step_adapters: nil); end
end
module Dry::Transaction
  def self.included(klass); end
end
class Dry::Transaction::StepAdapters
  extend Anonymous_Module_42
  extend Dry::Configurable
  extend Dry::Configurable::ClassMethods
  extend Dry::Container::Mixin
end
class Dry::Transaction::StepAdapters::Check
  def call(operation, _options, args); end
  include Dry::Monads::Result::Mixin
end
class Dry::Transaction::StepAdapters::Map
  def call(operation, _options, args); end
  include Dry::Monads::Result::Mixin
end
class Dry::Transaction::InvalidStepError < ArgumentError
  def initialize(step_name); end
end
class Dry::Transaction::MissingStepError < ArgumentError
  def initialize(step_name); end
end
class Dry::Transaction::InvalidResultError < ArgumentError
  def initialize(step_name); end
end
class Dry::Transaction::MissingCatchListError < ArgumentError
  def initialize(step_name); end
end
class Dry::Transaction::StepAdapters::Around
  def call(operation, options, args, &block); end
  include Dry::Monads::Result::Mixin
end
class Dry::Transaction::StepAdapters::Raw < Dry::Transaction::StepAdapters::Around
  def call(operation, options, args); end
end
class Dry::Transaction::StepAdapters::Tee
  def call(operation, _options, args); end
  include Dry::Monads::Result::Mixin
end
class Dry::Transaction::StepAdapters::Try
  def call(operation, options, args); end
  include Dry::Monads::Result::Mixin
end
module Anonymous_Module_42
  def inherited(subclass); end
end
class Dry::Transaction::StepFailure
  def initialize(step, value); end
  def self.call(step, value); end
  def step; end
  def value; end
end
class Dry::Transaction::Callable
  def arity; end
  def call(*args, &block); end
  def initialize(operation); end
  def operation; end
  def self.[](callable); end
end
class Dry::Transaction::StepAdapter
  def adapter; end
  def call(args, &block); end
  def initialize(adapter, operation, options); end
  def operation; end
  def options; end
  def self.[](adapter, operation, options); end
  def with(operation = nil, new_options = nil); end
  def yields?; end
end
class Dry::Transaction::Step
  def adapter; end
  def arity; end
  def call(input, continue = nil); end
  def call_args; end
  def external?; end
  def initialize(adapter:, name:, operation_name:, options:, operation: nil, call_args: nil); end
  def internal?; end
  def name; end
  def operation; end
  def operation_name; end
  def with(operation: nil, call_args: nil); end
  def with_broadcast(args); end
  extend Dry::Events::Publisher::ClassMethods
  include Anonymous_Dry_Events_Publisher_43
  include Dry::Events::Publisher::InstanceMethods
  include Dry::Monads::Result::Mixin
end
module Anonymous_Dry_Events_Publisher_43
end
class Dry::Transaction::DSL < Module
  def define_dsl; end
  def define_steps; end
  def initialize(step_adapters:); end
  def inspect; end
end
class Dry::Transaction::Stack
  def call(m); end
  def compile(steps); end
  def initialize(steps); end
end
module Dry::Transaction::InstanceMethods
  def assert_step_arity; end
  def assert_valid_step_args(step_args); end
  def call(input = nil, &block); end
  def initialize(steps: nil, listeners: nil, **operations); end
  def listeners; end
  def method_missing(name, *args, &block); end
  def operations; end
  def resolve_operation(step, **operations); end
  def respond_to_missing?(name, _include_private = nil); end
  def stack; end
  def steps; end
  def subscribe(listeners); end
  def with_step_args(**step_args); end
  include Dry::Monads::Result::Mixin
end
class Dry::Transaction::OperationResolver < Module
  def initialize(container); end
end
class Dry::Transaction::Builder < Module
  def dsl_mod; end
  def included(klass); end
  def initialize(step_adapters:, container: nil); end
  def resolver_mod; end
end
module Dry::Transaction::Operation
  def self.included(klass); end
end
